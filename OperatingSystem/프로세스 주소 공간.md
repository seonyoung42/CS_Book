# 프로세스 주소 공간
> 프로세스가 자신만의 방법으로 메모리를 관리하기 위한 구조
> 

<img width="655" alt="images-klm03025-post-cd3ef853-de73-4a07-b062-263ff9d1acdc-image" src="https://user-images.githubusercontent.com/77603632/237015745-25642408-dd82-4ea2-bf3e-cebe7dc196cf.png">

### Stack
> 함수와 함수 안의 지역변수, 매개변수를 저장하는 영역
- 함수 호출 시 할당되고 함수 호출 완료되면 소멸
- **컴파일 시 크기가 결정**되기에 무한 할당 불가
- 재귀 함수가 너무 깊게 호출되거나 함수가 지역변수를 많이 가지고 있어 stack 영역을 초과하면 **Stack Overflow** 에러 발생
- 읽고 쓰기 가능
- 메모리의 상위 주소 -> 하위 주소 방향으로 할당
    - 이유1 : 프로그램이 실행될 때 메모리를 얼마나 사용할지 계산할 수 없기 때문에 stack 함수의 뒷부분에서부터 변수의 주소가 매겨진다. 따라서 FFFFFFFF 근처의 메모리 값을 가지고 변수 선언 순서에 따라 상위 주소에서 하위 주소로 내려감
    - 이유2 : 스택 영역의 상위 주소에 커널영역이 존재하기 때문에, 변수에 스택 영역을 초과하는 크기의 메모리를 저장하면 커널 영역을 침범할 위험 있음

<br>

### Heap
> 런타임에 크기가 결정되는 메모리 영역
- 사용자에 의해 공간이 동적으로 할당 및 해제
- 주로 참조형 데이터 (ex. 클래스) 등의 데이터가 할당
- 메모리의 하위 주소 -> 상위 주소 방향으로 할당

<br>

### Data
> 전역 변수, 정적 변수와 같이 프로그램이 사용할 수 있는 함수 바깥의 데이터를 저장하는 영역
- 어떤 프로그램에 전역/정적 변수를 참조하는 코드가 존재한다면 그 프로그램은 컴파일 된 후에 data 영역 참조
- 프로그램의 시작 시 할당, 프로그램이 종료되면 소멸
- 컴파일 시 크기 결정
- 읽고 쓰기 가능

<br>

### Text(Code)
> 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장되어 있는 영역
- 컴파일 시 크기 결정
- 읽기만 가능

<br>

### 구역을 나누어 관리하는 이유?
=> 공유할 수 있는 부분은 공유하며 메모리 사용량을 줄이고자 구역을 나누어 관리
+ Text(Code) 영역은 같은 프로그램 내에서는 모두 같은 내용이기 때문에 따로 관리하여 공유

