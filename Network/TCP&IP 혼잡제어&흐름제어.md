# TCP/IP
> 온라인 상의 안전하고 효율적인 데이터 전송을 위해 필요한 통신 프로토콜의 모음으로 
> 
> 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약이다.
+ TCP => 데이터의 추적, IP => 배달 처리

### TCP
> 전송 제어 프로토콜 (Transmission Control Protocol) 으로 두 호스트가 교환하는 데이터와 승인 메세지의 형식을 정의하여, 서버와 클라이언트간의 데이터를 신뢰성있게 전달하기 위해 만들어진 규약
+ 데이터 패킷에 일련의 번호를 부여함으로써, 데이터 손실을 찾아내서 교정하고, 순서를 재조합하여 클라이언트에게 전달할 수 있게 한다.
+ 높은 신뢰성

### IP
> 인터넷 프로토콜 (Internet Protocol) 으로 인터넷에서 컴퓨터의 위치를 찾아서 데이터를 전송하기 위해 지켜야 할 규약
> 
> ex) 192.168.100.100
+ TCP와 달리 데이터의 재조합이나 손실여부 확인이 불가능하며, 단지 데이터를 전달하는 역할만을 담당한다.

<br>

## 흐름 제어
> 송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 방법

<br>

### 흐름 제어 방법

#### 1. Stop and Wait
+ 전송한 패킷에 대한 확인 응답(ACK)를 받은 후에 다음 패킷을 전송하는 방법
+ 패킷을 하나씩 보내기 때문에 비효율적이다.

#### 2. Sliding Window
+ 수신 측에서 설정한 윈도우 크기 만큼 송신 측에서 확인 응답 없이 패킷을 전송하는 방법

<br>

### 흐름제어를 하지 않는다면?

수신 측이 송신 측보다 데이터 처리 속도가 빠르다면 상관 없지만, 그 반대의 경우 문제가 발생한다.

수신 측에서 제한된 저장 용량으 초과한 이후에 도착하는 패킷이 손실될 수 있으며, 만얀 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다.


<br>

## 혼잡 제어
> 데이터의 양이 라우터가 처리할 수 있는 양으 초과하는 경우를 예방하기 위해 송신 측의 전송 속도르 조절하는 방법

<br>

### 혼잡 제어 방법
#### 1. AIMD ((Additive Increase/Multicative Decrease)
+ 패킷을 하나씩 보내고 문제 없이 도착한다면, 크기를 1씩 증가시키며 전송하는 방법
    + 만약 전송에 실패하면 크기를 반으로 줄임
+ 크기를 너무 조금씨 증가시키기 때문에 제대로 된 속도로 통신하기까지 시간이 오래 걸림

#### 2. Slow Start
+ 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방법
+ 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 느리게 증가하지만 시간이 갈수록 윈도우 크기가 빠르게 증가

#### 3. Fast Retransmit (빠른 재전송)
+ 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 이 ACK를 중복으로 3개 받으면 재전송하는 방법
+ 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있음

#### 4. Fast Recovery (빠른 회복)
+ 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법
    + 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작함

<br>

### 혼잡제어를 하지 않는다면?

데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 

이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다.

<br>

# 🙇🏻‍♀️ 참고
https://velog.io/@rosewwross/TCPIP
